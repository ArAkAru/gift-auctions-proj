## Описание
- Аукцион состоит из нескольких раундов
- В каждом раунде часть участников из топ N мест получает товар
- Остальные продолжают участие в следующих раундах
- TODO: уточнить могут ли в послед. раундах быть новые участники, или только те которые не прошли в N-1 раунде

## Цикл Раунда
 - Таймер запускается, участники могут делать ставки
 - Ставки принимаются, рейтинг обновляется в реальном времени
 - Таймер истёк, определяются победители
 - TODO: защита от тех кто будет ставить в последние секунды(Anti-sniping) - когда будет конец раунда, если       пользователи в послдение N секунд будут перебивать друг друга довольно долгое время?
 - Топ-N участников получают товары, их ставки списываются
 - Остальные участники переносятся в следующий раунд со своими ставками

## Создал основные сущности для аукицона
 - см. src/entities
  - Auction - сам аукцион
  - Bidder - участник торогов
  - Bid - сама ставка

## Создал модели для бд mongo и сервисы к ним, чтобы хранить/получать данные из бд
 - см. src/models / src/services

## Создал основные endpoints для создания/получения сущностей выше
 - см. src/routes

 TODO:
  - ~~обвешать логикой/проверками/защитой метод создания ставки~~ ✅
  - ~~написать какй-нибудь scheduler который постоянно проверял бы момент окончания раунда, распределения победителей и начало след раунда/конец всего аукциона~~ ✅
  - понять как мы хотим делить все товары на кол-во раундов - давать ли выбор пользовтелю чтобы он все вводил, или чтобы система сам высчитывала что 100 товаров по 3 на раунд это 99 товаров
  - ~~непонятно с antiSniping защитой, сколько мы будем продлевать раунд? поставлю ограничение, мы же не можем до утра проводить 1 раунд(стоит уточнить)~~ ✅ maxAntiSnipingExtensions
  - написать симуляцию ботов с разными режимами (дефолт пользователь который просто хочет оставаться в топе, агресивный который постоянно хочет быть в топ 1, снайпер который пытается попасть в топ в последние секунды раунда, на границе защиты от antisnipping)

---

## Механика защиты системы

### 1. Защита от падений (Crash Recovery)

Система использует **MongoDB транзакции** для атомарности критических операций.

#### Транзакция в `endRound()` (auction.service.ts)
```
┌─ startTransaction ─────────────────────────────────────┐
│  1. Получить аукцион                                   │
│  2. Найти топ-N ставок                                 │
│  3. Для каждой победившей ставки:                      │
│     - Установить статус WON                            │
│     - Списать средства (charge)                        │
│  4. Обновить аукцион (следующий раунд или завершение) │
│  5. Вернуть деньги проигравшим (refund)               │
└─ commitTransaction ────────────────────────────────────┘

При ошибке → abortTransaction → все изменения откатываются
```

#### Транзакция в `holdFundsAndSaveBid()` (bid.service.ts)
```
┌─ startTransaction ──────────────────┐
│  1. Заблокировать средства (hold)   │
│  2. Сохранить ставку                │
└─ commitTransaction ─────────────────┘

Защищает от: деньги заблокированы, но ставка не создана
```

### 2. Защита от параллельных запросов (Race Conditions)

Система использует **Distributed Lock** на базе MongoDB.

#### Модель Lock (models/lock.model.ts)
```typescript
{
  _id: string,        // "bid:auction123:user456"
  lockedUntil: Date,  // Когда истекает блокировка
  lockedBy: string    // UUID процесса, который взял блокировку
}
```

#### LockService (services/lock.service.ts)
```typescript
await lockService.withLock(lockKey, async () => {
  // Критическая секция - только один процесс может выполнять
});
```

#### Защищённые операции:

| Операция | Lock Key | Что защищает |
|----------|----------|--------------|
| `endRound()` | `auction:endRound:{auctionId}` | Двойное завершение раунда |
| `start()` | `auction:start:{auctionId}` | Двойной старт аукциона |
| `placeBid()` | `bid:{auctionId}:{bidderId}` | Двойная блокировка денег |

### 3. Защита от дублей ставок

**Уникальный индекс в MongoDB** (models/bid.model.ts):
```typescript
BidSchema.index({ auctionId: 1, bidderId: 1 }, { unique: true });
```

Один пользователь = одна активная ставка на аукцион.

### 4. Защита от многоинстансности (Multi-Instance)

Distributed Lock хранится в **общей MongoDB**, поэтому работает между инстансами:

```
┌──────────┐  ┌──────────┐  ┌──────────┐
│  App #1  │  │  App #2  │  │  App #3  │
└────┬─────┘  └────┬─────┘  └────┬─────┘
     │             │             │
     └─────────────┼─────────────┘
                   │
           ┌───────▼───────┐
           │    MongoDB    │
           │  locks коллекция │
           └───────────────┘
           
Только один инстанс получит lock

### 5. Автоочистка зависших блокировок

**TTL Index** автоматически удаляет истёкшие блокировки:
LockSchema.index({ lockedUntil: 1 }, { expireAfterSeconds: 0 });

Если инстанс упал с блокировкой → через 30 сек блокировка автоматически освободится.

### 6. MongoDB Replica Set (Требование)

**Транзакции работают только с Replica Set!**

docker-compose.yml настроен для инициализации replica set:
```yaml
mongo:
  command: ["--replSet", "rs0", "--bind_ip_all"]

mongo-init:
  # Инициализирует replica set при первом запуске
  entrypoint: ["bash", "/scripts/mongo-init-replica.sh"]
```

### Итоговая архитектура защиты

```
         HTTP запрос
              │
              ▼
    ┌─────────────────────┐
    │   Валидация         │  ← Быстрые проверки без lock
    │   (auction exists,  │
    │    status, minBid)  │
    └──────────┬──────────┘
               │
               ▼
    ┌─────────────────────┐
    │   Distributed Lock  │  ← Защита от параллельных запросов
    │   withLock(...)     │
    └──────────┬──────────┘
               │
               ▼
    ┌─────────────────────┐
    │   MongoDB Транзакция│  ← Атомарность операций
    │   startTransaction  │
    │   ...               │
    │   commitTransaction │
    └──────────┬──────────┘
               │
               ▼
          Ответ клиенту
```
